/**
 * @namespace Address
 */

const validator = require('../../utils/validator')
const db = require('../../utils/db')
const request = require('request')
const config = require('../../config')
const qs = require('querystring')

const Context = require('../Context')
const Metric = require('../../models/Metric')
const Recommendation = require('../../models/Recommendation/create')


const Address = {
  ...require('./get')
}

/**
 * PostgreSQL/PostGIS extension: **Geometry**(`Point`, `4326`)
 * @typedef point
 * @type {object}
 * @memberof Address
 * @instance
 */

/**
 * Geo-location service source
 * * `OSM`
 * * `Google`
 * * `Yahoo`
 * * `Bing`
 * * `Geonames`
 * * `Unknown`
 * * `None`
 * @typedef geo_source
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * GoogleMaps confidence and accuracy level for this address
 * * `APPROXIMATE`
 * * `RANGE_INTERPOLATED`
 * * `GEOMETRIC_CENTER`
 * * `ROOFTOP`
 * @typedef geo_confidence_google
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * Microsoft Bing confidence and accuracy level for this address
 * * `High`
 * * `Medium`
 * * `Low`
 * @typedef geo_confidence_bing
 * @enum {string}
 * @memberof Address
 * @instance
 */

/**
 * @typedef address
 * @type {object}
 * @memberof Address
 * @instance
 * @property {uuid} id - ID of this `address`
 * @property {string=} title - title
 * @property {string=} subtitle - subtitle
 * @property {string=} street_number - street number
 * @property {string=} street_name - street name
 * @property {string} city - city
 * @property {string} state - state
 * @property {string} state_code - state code
 * @property {string=} postal_code - postal code
 * @property {string=} neighborhood - neighborhood
 * @property {string=} street_suffix - street suffix
 * @property {string=} street_dir_suffix - street direction suffix
 * @property {string=} street_dir_prefix - street direction prefix
 * @property {string=} unit_number - unit number
 * @property {string} country - full country name
 * @property {string} country_code - 3 letter country code
 * @property {string=} direction - direction
 * @property {string=} street_number_searchable - searchable street number
 * @property {string=} county_or_parish - county or parish related to this address
 * @property {string=} geo_source_formatted_address_google - full formated address response generated by GoogleMaps API for this address
 * @property {string=} geo_source_formatted_address_bing - full formatted address response generated by Microsoft Bing API for this address
 * @property {Address#point=} location_google - GoogleMaps designated location for this address
 * @property {Address#point=} location_bing - Microsoft Bing designated location for this address
 * @property {Address#point=} location - our chosen location for this address
 * @property {Address#geo_source} geo_source - our chosen geo-location service source for this address
 * @property {Address#geo_confidence_google=} geo_confidence_google - GoogleMaps confidence and accuracy level for this address
 * @property {Address#geo_confidence_bing=} geo_confidence_bing - Microsoft Bing confidence and accuracy level for this address
 * @property {boolean=} geocoded_google - indicates whether this address is geocoded by GoogleMaps
 * @property {boolean=} geocoded_bing - indicates whether this address is geocoded by Bing
 * @property {boolean=} geocoded - indicates whether we have a decision on geocoding for this address
 * @property {boolean=} corrupted_google - indicates whether GoogleMaps was able to come up with an answer for this address
 * @property {boolean=} corrupted_bing - indicates whether Microsoft Bing was able to come up with an answer for this address
 * @property {boolean=} corrupted - indicates whether this address is corrupted based on our internal logic
 * @property {boolean=} approximate - A map for these addresses show not showup on client applications, since this is an estimated location
 * @property {boolean=} partial_match_google - partial match property indicator from GoogleMaps responses
 * @property {timestamp} created_at - indicates when this object was created
 * @property {timestamp=} updated_at - indicates when this object was last modified
 * @property {timestamp=} deleted_at - indicates when this object was deleted
 */

const schema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      required: true
    },

    subtitle: {
      type: 'string',
      required: true
    }
  }
}

const validate = validator.promise.bind(null, schema)

/**
 * Creates an address object
 * @name create
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {Address#address} address - full address object
 * @param {callback} cb - callback function
 * @returns {Address#address}
 */
Address.create = async address => {
  await validate(address)


  const { rows } = await db.query.promise('address/create', [
    address.title,
    address.subtitle,
    address.street_suffix,
    address.street_number,
    address.street_name,
    address.city,
    address.state,
    address.state_code,
    address.country,
    address.country_code,
    address.unit_number,
    address.postal_code,
    address.neighborhood,
    address.matrix_unique_id,
    address.county_or_parish,
    address.direction,
    address.street_dir_prefix,
    address.street_dir_suffix,
    address.street_number_searchable,
    address.mls
  ])

  return rows[0].id
}

/**
 * Maps an `Address` object based on Matrix_Unique_ID to a `Listing` object
 * @name mapToListing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {listing} full listing object
 */
Address.mapToListing = function (address_id, cb) {
  Address.get(address_id).nodeify(function (err, address) {
    if (err)
      return cb(err)

    db.query('address/map_to_listing', [address_id], function (err, res) {
      if (err)
        return cb(err)

      if (res.rows.length > 0)
        return cb(null, res.rows[0].id)

      return cb(null, null)
    })
  })
}

/**
 * Reschedules an address for generating `Recommendation` objects. This happens
 * when an address gets an updated geo-location information from one of our sources
 * @name reschedule
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Recommendation#recommendation[]} full listing object
 */
Address.reschedule = function (address_id, cb) {
  Address.mapToListing(address_id, (err, listing_id) => {
    if(err)
      return cb(err)

    if (!listing_id)
      return cb(null, null)

    return Recommendation.generateForListing(listing_id, cb)
  })
}

/**
 * Updates geo-location information for an `Address` object from GoogleMaps API.
 * The following changes may happen on an `Address` object following this call:
 * * If the address in question gets a not found response from GoogleMaps, `corrupted_google` will be set to true
 * * If the address in question gets a partial match response from GoogleMaps, `partial_match` will be set to true
 * * GoogleMaps API formatted address field will be placed in `geo_source_formatted_address_google`
 * * `geo_confidence_google` will be set to the GoogleMaps API `location_type` field
 * * `approximate` field will be set to _true_ if the confidence is equal to `APPROXIMATE`, _false_ otherwise.
 * @name updateGeoFromGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
// const cache_key = 'google_geocoded_addresses'

/**
 * Disabled
 */
Address.updateGeoFromGoogle = function (address_id, cb) {
  return cb()
  // let search_string

  // const markAsCorrupt = (e) => {
  //   Context.log('(Google) Geocoding failed:'.yellow, address_id, e)
  //   return Address.markAsCorruptedGoogle(address_id, cb)
  // }

  // const processResponse = (body) => {
  //   if (!body) {
  //     return markAsCorrupt('Response body is empty')
  //   }

  //   try {
  //     body = JSON.parse(body)
  //   } catch (e) {
  //     return markAsCorrupt('Unable to parse response body')
  //   }

  //   if (body.status !== 'OK') {
  //     Context.log(body)
  //     return markAsCorrupt(`Body status should be ok but it is ${body.status}`)
  //   }

  //   redis.hset(cache_key, search_string, JSON.stringify(body))

  //   if (!body.results[0]) {
  //     return markAsCorrupt('No result found')
  //   }

  //   const location = {}
  //   let partial, confidence, formatted_address, approximate

  //   try {
  //     location.latitude = body.results[0].geometry.location.lat
  //     location.longitude = body.results[0].geometry.location.lng
  //     partial = body.results[0].partial_match
  //     confidence = body.results[0].geometry.location_type
  //     formatted_address = body.results[0].formatted_address
  //     approximate = (confidence === 'APPROXIMATE') ? true : false
  //   } catch (e) {
  //     return markAsCorrupt('Missing necessary information')
  //   }

  //   Context.log('(Google) Geocode completed:'.green, 'confidence:', confidence)

  //   Address.updateLatLongGoogle(address_id, location, {
  //     formatted_address: formatted_address,
  //     source: 'Google',
  //     partial: partial,
  //     confidence: confidence,
  //     approximate: approximate
  //   }, function (err, address) {
  //     if (err)
  //       return cb(err)

  //     return cb(null, address.id)
  //   })
  // }

  // Address.get(address_id).nodeify(function (err, address) {
  //   if (err)
  //     return cb(err)

  //   search_string = Address.getGeocodingSearchString(address)
  //   // eslint-disable-next-line handle-callback-err
  //   redis.hget(cache_key, search_string, (err, cached) => {
  //     if (cached) {
  //       Metric.increment('geocode.google.cache')
  //       return processResponse(cached)
  //     }

  //     request(config.google.url + (config.google.use_key ? ('?key=' + config.google.api_key + '&') : ('?')) + 'address=' + qs.escape(search_string), function (err, response, body) {
  //       Metric.increment('geocode.google')

  //       if (err)
  //         return cb(err)

  //       processResponse(body)
  //     })
  //   })
  // })
}

/**
 * Updates geo-location information for an `Address` object from Bing API.
 * The following changes may happen on an `Address` object following this call:
 * * If the address in question gets a not found response from Bing API, `corrupted_bing` will be set to true
 * * Bing API formatted address field will be placed in `geo_source_formatted_address_bing`
 * * `geo_confidence_bing` will be set to the Bing API `confidence` field
 * * `approximate` field will be set to _false_ if confidence is `High`, _true_ otherwise.
 * @name updateGeoFromBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateGeoFromBing = function (address_id, cb) {
  Metric.increment('geocode.bing')

  Address.get(address_id).nodeify(function (err, address) {
    if (err)
      return cb(err)

    const standard = Address.getGeocodingSearchString(address)
    request(config.bing.url + '?q=' + qs.escape(standard) + '&key=' + config.bing.api_key, function (err, response, body) {
      if (err)
        return cb(err)

      if (body) {
        try {
          body = JSON.parse(body)
          if (body.statusCode === 200) {
            if (body.resourceSets[0]) {
              if (body.resourceSets[0].resources) {
                if (body.resourceSets[0].resources[0]) {
                  const location = {}
                  location.latitude = body.resourceSets[0].resources[0].point.coordinates[0]
                  location.longitude = body.resourceSets[0].resources[0].point.coordinates[1]
                  const partial = false // Not Available
                  const confidence = body.resourceSets[0].resources[0].confidence
                  const formatted_address = body.resourceSets[0].resources[0].address.formattedAddress
                  const approximate = (confidence === 'High') ? false : true

                  Context.log('(Bing-Direct) NOTICE: UPDATING LAT/LONG for address with id:',
                    address_id, '(', standard, ') location:', location, 'confidence:', confidence)
                  Address.updateLatLongBing(address_id, location, {
                    formatted_address: formatted_address,
                    source: 'Bing',
                    partial: partial,
                    confidence: confidence,
                    approximate: approximate
                  }, function (err, address) {
                    if (err)
                      return cb(err)

                    return cb(null, address.id)
                  })
                } else {
                  Context.log(body)
                  Context.log('(Bing-Direct) WARNING[6]: Error geocoding an address with id:', address_id)
                  return Address.markAsCorruptedBing(address_id, cb)
                }
              } else {
                Context.log(body)
                Context.log('(Bing-Direct) WARNING[5]: Error geocoding an address with id:', address_id)
                return Address.markAsCorruptedBing(address_id, cb)
              }
            } else {
              Context.log(body)
              Context.log('(Bing-Direct) WARNING[1]: Error geocoding an address with id:', address_id)
              return Address.markAsCorruptedBing(address_id, cb)
            }
          } else {
            Context.log(body)
            Context.log('(Bing-Direct) WARNING[2]: Error geocoding an address with id:', address_id)
            Context.log(body)
            return Address.markAsCorruptedBing(address_id, cb)
          }
        }
        catch (e) {
          Context.log(body)
          Context.log('(Bing-Direct) WARNING[3]: Error geocoding an address with id:', address_id, 'with exception:', e)
          return Address.markAsCorruptedBing(address_id, cb)
        }
      } else {
        Context.log('(Google-Direct) WARNING[4]: Error geocoding an address with id:', address_id)
        return Address.markAsCorruptedBing(address_id, cb)
      }
    })
  })
}

/**
 * Updates our chosen geo-location information based on the following policy:
 * * If GoogleMaps API has an entry with confidence level `ROOFTOP` then we use that otherwise
 * * If Bing has an entry with confidence level `High` then we use that otherwise
 * * If GoogleMaps has an entry with confidence level `RANGE_INTERPOLATED` then we use that otherwise
 * * If GoogleMaps has an entry with confidence level `GEOMETRIC_CENTER` then we use that, also setting `approximate field` otherwise
 * * If Bing has an entry that matches our postal code and street name then we use that and `approximate` is set otherwise
 * * If GoogleMaps has an entry that matches our postal code and street name then we use that and `approximate` is set otherwise
 * * If Bing has an entry that matches our postal code then we use that and `approximate` is set otherwise
 * * If Google has an entry that matches our postal code then we use that and `approximate` is set otherwise
 * * We use Bing and `approximate` is set
 * @name updateGeo
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateGeo = function (id, cb) {
  if (config.geo.enabled === false) return cb()

  Metric.increment('geocode')

  Address.updateGeoFromGoogle(id, function (err, address_id) {
    if (err)
      return cb(err)

    Address.updateGeoFromBing(id, function (err, address_id) {
      if (err)
        return cb(err)

      Address.get(id).nodeify((err, address) => {
        if(err)
          return cb(err)

        const gsfa_google = address.geo_source_formatted_address_google || ''
        const gsfa_bing = address.geo_source_formatted_address_bing || ''
        const gc_google = address.geo_confidence_google || ''
        const gc_bing = address.geo_confidence_bing || ''
        const g_bing = address.geocoded_bing

        if (gc_google === 'ROOFTOP') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: false}, cb)
        } else if (gc_bing === 'High') {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: false}, cb)
        } else if (gc_google === 'RANGE_INTERPOLATED') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: false}, cb)
        } else if (gc_google === 'GEOMETRIC_CENTER') {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        }

        if (gsfa_bing.indexOf(address.postal_code) !== -1 && gsfa_bing.indexOf(address.street_name) !== -1) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        } else if (gsfa_google.indexOf(address.postal_code) !== -1 && gsfa_google.indexOf(address.street_name) !== -1) {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        } else if (gsfa_bing.indexOf(address.postal_code) !== -1) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        } else if (gsfa_google.indexOf(address.postal_code) !== -1) {
          return Address.updateLatLong(id, address.location_google, {source: 'Google', approximate: true}, cb)
        } else if (g_bing) {
          return Address.updateLatLong(id, address.location_bing, {source: 'Bing', approximate: true}, cb)
        }

        return Address.markAsCorrupted(id, cb)
      })
    })
  })
}

/**
 * Marks an `Address` object as corrupted
 * @name markAsCorrupted
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorrupted = function (address_id, cb) {
  db.query('address/mark_as_corrupted', [address_id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Marks an `Address` object as not convertible to geo-location by GoogleMaps API
 * @name markAsCorruptedGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorruptedGoogle = function (address_id, cb) {
  db.query('address/mark_as_corrupted_google', [address_id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Marks an `Address` object as not convertible to geo-location by Bing API
 * @name markAsCorruptedBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {boolean}
 */
Address.markAsCorruptedBing = function (id, cb) {
  db.query('address/mark_as_corrupted_bing', [id], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, false)
  })
}

/**
 * Updates an `Address` object GoogleMaps API geo-location information
 * @name updateLatLongGoogle
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Address#address} full address object
 */
Address.updateLatLongGoogle = function (address_id, location, aux, cb) {
  db.query('address/update_latlong_google', [
    location.longitude,
    location.latitude,
    aux.partial,
    aux.formatted_address,
    aux.confidence,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    Address.get(address_id).nodeify(cb)
  })
}

/**
 * @param {UUID} address_id
 * @param {import('../../types/models/MLS').IRechatGeocode} geocode_result
 * @returns {Promise<{ id: UUID; location: any; }>}
 */
Address.updateLatLongMapbox = async function(address_id, geocode_result) {
  return db.selectOne('address/update_latlong_mapbox', [
    geocode_result.longitude,
    geocode_result.latitude,
    geocode_result.formatted_address,
    geocode_result.confidence,
    address_id
  ])
}

/**
 * @param {UUID} address_id
 * @param {number} longitude
 * @param {number} latitude
 * @returns {Promise<{ id: UUID; location: any; }>}
 */
Address.updateLatLongMLS = async function(address_id, longitude, latitude) {
  return db.selectOne('address/update_latlong_mls', [
    longitude,
    latitude,
    address_id
  ])
}

/**
 * Updates an `Address` object Bing API geo-location information
 * @name updateLatLongBing
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {Address#address} full address object
 */
Address.updateLatLongBing = function (address_id, location, aux, cb) {
  db.query('address/update_latlong_bing', [
    location.longitude,
    location.latitude,
    aux.formatted_address,
    aux.confidence,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    Address.get(address_id).nodeify(cb)
  })
}

/**
 * Updates an `Address` object geo-location information
 * @name updateLatLong
 * @function
 * @memberof Address
 * @instance
 * @public
 * @param {uuid} address_id - ID of the referenced address
 * @param {callback} cb - callback function
 * @returns {uuid} ID of the referenced address
 */
Address.updateLatLong = function (address_id, location, aux, cb) {
  db.query('address/update_latlong', [
    location,
    aux.source,
    aux.approximate,
    address_id
  ], function (err, res) {
    if (err)
      return cb(err)

    return cb(null, address_id)
  })
}


Address.fixMissing = function(cb) {
  db.query('address/fix_missing', [], (err, res) => {
    if(err)
      return cb(err)

    const ids = res.rows.map(r => r.id)

    return cb(null, ids)
  })
}


module.exports = Address
